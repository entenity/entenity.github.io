(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{381:function(t,n,e){"use strict";e.r(n);var o=e(26),a=Object(o.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("本文为慕课网 "),e("a",{attrs:{href:"http://www.imooc.com/learn/277",target:"_blank",rel:"noopener noreferrer"}},[t._v("JavaScript深入浅出"),e("OutboundLink")],1),t._v("  JavaScript 面向对象笔记。")]),t._v(" "),e("h2",{attrs:{id:"概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[t._v("#")]),t._v(" 概念")]),t._v(" "),e("blockquote",[e("p",[t._v("面向对象程序设计（Object-oriented programming，OOP）是一种程序设计范型，同时也是一种程序开发的方法。对象指的是类的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性。")]),t._v(" "),e("p",[t._v("——维基百科")])]),t._v(" "),e("p",[t._v("一般面向对象包含：继承，封装，多态，抽象")]),t._v(" "),e("hr"),t._v(" "),e("h2",{attrs:{id:"基于原型的继承"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基于原型的继承"}},[t._v("#")]),t._v(" 基于原型的继承")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("function Foo() {\n    this.y = 2;\n}\nconsole.log(typeof Foo.prototype); //object\n\nFoo.prototype.x = 1;\nvar obj3 = new Foo();\n\nconsole.log(obj3.y); //2\nconsole.log(obj3.x); //1\n")])])]),e("p",[t._v("创建函数 "),e("code",[t._v("Foo")]),t._v(" 的时候，就会有一个内置的 "),e("code",[t._v("Foo.prototype")]),t._v(" 属性，并且这个属性是对象。")]),t._v(" "),e("p",[t._v("在使用 "),e("code",[t._v("new Foo();")]),t._v(" 创建对象实例时。"),e("code",[t._v("this")]),t._v(" 会指向一个对象，并且这个对象的原型会指向 "),e("code",[t._v("Foo.prototype")]),t._v(" 属性。"),e("code",[t._v("this.y = 2")]),t._v(" 给这个对象赋值，并把这个对象返回。把这个对象赋值给 "),e("code",[t._v("obj3")]),t._v("。")]),t._v(" "),e("p",[e("code",[t._v("y")]),t._v(" 是 "),e("code",[t._v("obj3")]),t._v(" 上的，"),e("code",[t._v("x")]),t._v(" 是 "),e("code",[t._v("obj3")]),t._v(" 的原型 "),e("code",[t._v("Foo.prototype")]),t._v(" 上的。")]),t._v(" "),e("p",[e("img",{attrs:{src:"http://7q5cdt.com1.z0.glb.clouddn.com/blog-prototype.png",alt:"prototype"}})]),t._v(" "),e("hr"),t._v(" "),e("h3",{attrs:{id:"prototype-属性与原型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#prototype-属性与原型"}},[t._v("#")]),t._v(" prototype 属性与原型")]),t._v(" "),e("p",[t._v("prototype 是函数对象上预设的对象属性。")]),t._v(" "),e("p",[t._v("原型是对象上的原型，通常是构造器的 prototype 属性。")]),t._v(" "),e("hr"),t._v(" "),e("h4",{attrs:{id:"例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#例"}},[t._v("#")]),t._v(" 例")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("function Person(name, age) {\n    this.name = name;\n    this.age = age;\n}\n\nPerson.prototype.LEGS_NUM = 2;\nPerson.prototype.ARMS_NUM = 2;\n\nPerson.prototype.hi = function() {\n    console.log('Hi, my name is ' + this.name + \". I'm \" + this.age + ' years old now');\n};\n\nPerson.prototype.walking = function() {\n    console.log(this.name + ' is walking...');\n};\n\nfunction Student(name, age, className) {\n    Person.call(this, name, age); //使 Person 中的 this 指向 Student\n    this.className = className;\n}\n\nStudent.prototype = Object.create(Person.prototype);\nStudent.prototype.constructor = Student;\n\nStudent.prototype.hi = function() {\n    console.log('Hi, my name is ' + this.name + \". I'm \" + this.age + ' years old now, and from ' + this.className + \".\");\n};\n\nStudent.prototype.learn = function(subject) {\n    console.log(this.name + ' is learning ' + subject + ' at ' + this.className + '.');\n}\n\n//test\nvar gao = new Student('Gao', '24', 'Class 3123');\nconsole.log(gao); // 这个对象的具体内容见下图\ngao.hi(); //Hi, my name is Gao. I'm 24 years old now, and from Class 3123.\ngao.LEGS_NUM; //2\ngao.walking(); //Gao is walking...\ngao.learn('JavaScript'); //Gao is learning JavaScript at Class 3123.\n")])])]),e("ul",[e("li",[e("code",[t._v("Object.create(arg)")]),t._v(" 创建一个空对象，并且这个对象的原型指向参数 "),e("code",[t._v("arg")]),t._v("。")]),t._v(" "),e("li",[e("code",[t._v("Student.prototype.constructor = Student")]),t._v(" 为了保证一致性，否则 constructor 指向 Person。")])]),t._v(" "),e("hr"),t._v(" "),e("h3",{attrs:{id:"原型链"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原型链"}},[t._v("#")]),t._v(" 原型链")]),t._v(" "),e("p",[t._v("gao 对象的原型链：")]),t._v(" "),e("p",[e("img",{attrs:{src:"http://7q5cdt.com1.z0.glb.clouddn.com/blog-oop-gao.png",alt:"Object"}})]),t._v(" "),e("p",[t._v("下面通过图形展示原型链：")]),t._v(" "),e("p",[e("img",{attrs:{src:"http://7q5cdt.com1.z0.glb.clouddn.com/blog-%E5%8E%9F%E5%9E%8B%E9%93%BE.png",alt:"原型链"}})]),t._v(" "),e("hr"),t._v(" "),e("h4",{attrs:{id:"object-create-null-bind-null"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#object-create-null-bind-null"}},[t._v("#")]),t._v(" "),e("code",[t._v("Object.create(null)")]),t._v(" & "),e("code",[t._v(".bind(null)")])]),t._v(" "),e("p",[t._v("这两种算是特例。")]),t._v(" "),e("p",[e("code",[t._v("Object.create(null)")]),t._v(" 和 "),e("code",[t._v(".bind(null)")]),t._v(" 这两种方式创建出来的对象是没有 "),e("code",[t._v("prototype")]),t._v(" 属性的，为 "),e("code",[t._v("undefined")]),t._v("。")]),t._v(" "),e("hr"),t._v(" "),e("h2",{attrs:{id:"prototype-属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#prototype-属性"}},[t._v("#")]),t._v(" prototype 属性")]),t._v(" "),e("h3",{attrs:{id:"改变-prototype"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#改变-prototype"}},[t._v("#")]),t._v(" 改变 prototype")]),t._v(" "),e("p",[t._v("JavaScript 中的 prototype 是对象，在运行的时候可以修改。")]),t._v(" "),e("p",[t._v("给 prototype 添加或删除一些属性，是会影响到已经创建好的实例对象的。")]),t._v(" "),e("p",[t._v("但是，直接修改 prototype 属性，是不会影响到已经创建好的实例对象的。但是会影响到新的实例对象。如下代码：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("// 上接上面的代码\n\n// 给 prototype 添加或删除一些属性\nStudent.prototype.x = 101;\nconsole.log(gao.x); //101\n\n// 直接修改 prototype 属性\nStudent.prototype = {\n    y: 2\n};\n\n// 不会影响到已创建好的实例对象\nconsole.log(gao.x); //101\nconsole.log(gao.y); //undefined\n\n// 会影响到新创建的实例对象\nvar ying = new Student('Ying', 24, 'UI');\nconsole.log(ying.x); //undefined\nconsole.log(ying.y); //2\n")])])]),e("hr"),t._v(" "),e("h3",{attrs:{id:"内置构造器的-prototype-属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内置构造器的-prototype-属性"}},[t._v("#")]),t._v(" 内置构造器的 "),e("code",[t._v("prototype")]),t._v(" 属性")]),t._v(" "),e("p",[t._v("修改内置构造器的 "),e("code",[t._v("prototype")]),t._v(" 属性后，在实例化这个对象后，枚举其属性时，会把修改的内置构造器的 "),e("code",[t._v("prototype")]),t._v(" 属性也枚举出来，有时候这是要避免的。可用 "),e("code",[t._v("defineProperty")]),t._v(" 方法解决。如下代码：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("Object.prototype.x = 1;\nvar obj = {};\nconsole.log(obj.x); //1\nconsole.log(obj);\n\nfor (var k in obj) {\n    console.log('result---\x3e' + k);\n}\n// result---\x3ex\n")])])]),e("p",[t._v("使用 "),e("code",[t._v("defineProperty")]),t._v(" 后：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("Object.defineProperty(Object.prototype, 'x', {\n    writable: true,\n    value: 1\n});\nvar obj = {};\nconsole.log(obj.x);//1\nconsole.log(obj);\nfor (var k in obj) {\n    console.log('result---\x3e' + k);\n}\n// nothing output here\n")])])]),e("p",[t._v("其实也可以这样枚举，使用 "),e("code",[t._v("hasOwnProperty")]),t._v(" 方法：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('for (var key in obj) {\n    if (obj.hasOwnProperty(key)) {\n        console.log("result---\x3e" + key);\n    }\n}\n')])])]),e("hr"),t._v(" "),e("h3",{attrs:{id:"创建对象-new-原型链"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#创建对象-new-原型链"}},[t._v("#")]),t._v(" 创建对象-new/原型链")]),t._v(" "),e("p",[t._v("![prototype](http://7q5cdt.com1.z0.glb.clouddn.com/blog-new prototype.png)")]),t._v(" "),e("hr"),t._v(" "),e("h2",{attrs:{id:"instanceof"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#instanceof"}},[t._v("#")]),t._v(" instanceof")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("console.log([1, 2] instanceof Array); //true\nconsole.log([1, 2] instanceof Object); //true\nconsole.log(new Object() instanceof Array); //false\n")])])]),e("p",[t._v("左边要求是对象，右边要求是构造器或函数。它会判断："),e("strong",[t._v("右边的构造器中的 "),e("code",[t._v("prototype")]),t._v(" 属性是否出现在左边的对象的原型链上。")])]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("注意："),e("strong",[t._v("不同的 window 或 iframe 间的对象类型检测")]),t._v("不能")]),t._v("使用 "),e("code",[t._v("instanceof")]),t._v("！")])]),t._v(" "),e("hr"),t._v(" "),e("h2",{attrs:{id:"实现继承的方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现继承的方式"}},[t._v("#")]),t._v(" 实现继承的方式")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("function Person() {}\n\nfunction Student() {}\n\nStudent.prototype = Person.prototype; //1\n\nStudent.prototype = new Person(); //2\n\nStudent.prototype = Object.create(Person.prototype); //3\n\nStudent.prototype.constructor = Student;\n")])])]),e("p",[t._v("注释中：")]),t._v(" "),e("p",[t._v("1 是错误的。如果改变了 Student 就会改变 Person")]),t._v(" "),e("p",[t._v("2 可以实现继承，但是其调用了构造函数，若父类构造函数中有形参，那么传值就会比较奇怪。")]),t._v(" "),e("p",[t._v("3 是最好的方法。创建了一个空对象，并且对象的原型指向参数 Person.prototype。这样便实现了继承。同时原型链写，不向上查找。但是 "),e("code",[t._v("Object.create")]),t._v(" 是ES5 中的方法，所以可以使用下列代码做兼容：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("if (!Object.create) {\n    Object.create = function(proto) {\n        function F() {}\n        F.prototype = proto;\n        return new F;\n    };\n}\n")])])]),e("hr"),t._v(" "),e("h2",{attrs:{id:"模拟重载"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模拟重载"}},[t._v("#")]),t._v(" 模拟重载")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("function Person() {\n    var args = arguments;\n    if (typeof args[0] === 'object' && args[0]) {\n        if (args[0].name) {\n            this.name = args[0].name;\n        }\n        if(args[0].age){\n            this.age = args[0].age;\n        }\n    } else {\n        if (args[0]) {\n            this.name = args[0];\n        }\n        if (args[1]) {\n            this.age = args[1];\n        }\n    }\n}\n\n//重写 toString 方法\nPerson.prototype.toString = function() {\n    console.log('name='+this.name+', age='+this.age);\n};\n\nvar gao = new Person({name:'Gao',age:24});\ngao.toString(); // name=Gao, age=24\n\nvar ying = new Person('Ying',25);\nying.toString(); // name=Ying, age=25\n")])])]),e("p",[t._v("对参数进行判断，模拟实现重载。")]),t._v(" "),e("hr"),t._v(" "),e("h2",{attrs:{id:"调用子类方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#调用子类方法"}},[t._v("#")]),t._v(" 调用子类方法")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("function Person(name) {\n    this.name = name;\n}\n\nfunction Student(name, className) {\n    this.className = className;\n    Person.call(this, name); // 调用基类的构造器\n}\n\nvar gao = new Student('Gao', '3123');\nconsole.log(gao); // Student {className: \"3123\", name: \"Gao\"}\n\nPerson.prototype.init = function() {};\n\nStudent.prototype.init = function() {\n    // do sth...\n    Person.prototype.init.apply(this, arguments); // 同时也想调用父类被覆盖的方法\n};\n")])])]),e("p",[t._v("主要是两种：调用父类的构造器，调用原型链上父类被覆盖的方法。")]),t._v(" "),e("hr"),t._v(" "),e("h2",{attrs:{id:"链式调用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#链式调用"}},[t._v("#")]),t._v(" 链式调用")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("function ClassManager() {}\nClassManager.prototype.addClass = function(str) {\n    console.log('Class: ' + str + ' added');\n    return this;\n};\n\nvar manager = new ClassManager();\nmanager.addClass('classA').addClass('classB').addClass('classC');\n// Class: classA added\n// Class: classB added\n// Class: classC added\n")])])]),e("p",[t._v("重点在于 return this。返回这个 ClassManager 的实例。这样这个实例又可以继续调用方法。")]),t._v(" "),e("hr"),t._v(" "),e("h2",{attrs:{id:"抽象类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#抽象类"}},[t._v("#")]),t._v(" 抽象类")]),t._v(" "),e("p",[t._v("在构造器中 "),e("code",[t._v("throw new Error('');")]),t._v(" 抛异常。这样防止这个类被直接调用。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("function DetectorBase() {\n    throw new Error('Abstract class can not be invoked directly!');\n}\n\nDetectorBase.detect = function() {\n    console.log('Detection starting...');\n}\nDetectorBase.stop = function() {\n    console.log('Detection stopped.');\n};\nDetectorBase.init = function() {\n    throw new Error('Error');\n}\n\nvar d = new DetectorBase();// Uncaught Error: Abstract class can not be invoked directly!\n\nfunction LinkDetector() {}\nLinkDetector.prototype = Object.create(DetectorBase.prototype);\nLinkDetector.prototype.constructor = LinkDetector;\n\nvar l = new LinkDetector();\nconsole.log(l); //LinkDetector {}__proto__: LinkDetector\nl.detect(); //Uncaught TypeError: l.detect is not a function\nl.init(); //Uncaught TypeError: l.init is not a function\n")])])]),e("p",[e("code",[t._v("var d = new DetectorBase();")]),t._v(" 是不能实例化的，会报错")]),t._v(" "),e("p",[e("code",[t._v("l.detect();")]),t._v(" 但是这个为什么报错我就不知道了。")]),t._v(" "),e("p",[t._v("已经在原课程下提问了，期待老师的讲解。 "),e("a",{attrs:{href:"http://www.imooc.com/qadetail/82732",target:"_blank",rel:"noopener noreferrer"}},[t._v("抽象类中子类为什么不能调用父类的非抽象方法？"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("问题已经解决了，应该是老师当时的课件写错了，应该再基类中将这两个方法写在其原型 prototype 上。如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("function DetectorBase() {\n    throw new Error('Abstract class can not be invoked directly!');\n}\n\nDetectorBase.prototype.detect = function() {\n    console.log('Detection starting...');\n};\nDetectorBase.prototype.stop = function() {\n    console.log('Detection stopped.');\n};\nDetectorBase.prototype.init = function() {\n    throw new Error('Error');\n};\n\n// var d = new DetectorBase();// Uncaught Error: Abstract class can not be invoked directly!\n\nfunction LinkDetector() {}\nLinkDetector.prototype = Object.create(DetectorBase.prototype);\nLinkDetector.prototype.constructor = LinkDetector;\n\nvar l = new LinkDetector();\nconsole.log(l); //LinkDetector {}__proto__: LinkDetector\nl.detect(); //Detection starting...\nl.init(); //Uncaught Error: Error\n")])])]),e("hr"),t._v(" "),e("h2",{attrs:{id:"模块化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模块化"}},[t._v("#")]),t._v(" 模块化")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("var moduleA;\nmoduleA = function() {\n    var prop = 1;\n\n    function func() {}\n\n    return {\n        func: func,\n        prop: prop\n    };\n}(); // 立即执行匿名函数\n")])])]),e("p",[t._v("prop，func 不会被泄露到全局作用域。")]),t._v(" "),e("p",[t._v("或者另一种写法，使用 new")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("moduleA = new function() {\n    var prop = 1;\n\n    function func() {}\n\n    this.func = func;\n    this.prop = prop;\n}\n")])])]),e("p",[t._v("更复杂的可以使用 Sea.js Kissy Require.js 模块化工具。")]),t._v(" "),e("hr"),t._v(" "),e("p",[t._v("最后补充一点设计模式相关的资料，我还没有来得及看的：")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"http://www.oschina.net/translate/learning-javascript-design-patterns",target:"_blank",rel:"noopener noreferrer"}},[t._v("学用 JavaScript 设计模式"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"http://blog.jobbole.com/29454/",target:"_blank",rel:"noopener noreferrer"}},[t._v("常用的Javascript设计模式"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"http://developer.51cto.com/art/201109/288650_all.htm",target:"_blank",rel:"noopener noreferrer"}},[t._v("JavaScript设计模式深入分析"),e("OutboundLink")],1)])])])}),[],!1,null,null,null);n.default=a.exports}}]);